#include <stdio.h>
#include <windows.h> 

//callback called by the application when something happens
//CALLBACK macro evaluated to the same thing as WINAPI (__stdcall)
//But indicates that the operating system calls this, rather than the application
LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
 switch (uMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    //paint is generated by the OS to do things like create the window and resize ti etc
    //the application itself can also send these though
    case WM_PAINT:
        //in C, cases need brackets if a variable is declared in them, to keep them to the right scope
        {
           //still need to dive into what beginpaint does to this struct
           PAINTSTRUCT ps; 

           //returns a "device context" which is a pointer to a bunch
           //of shit that is passed to windowsGDL to draw
           //GDL being a cpu based rendering API - we will do GPU rendering laterr
           HDC hdc = BeginPaint(hwnd, &ps);
           
           //fillRect takes the hdc, a pointer to the RECT structure (which contains the coordinates we want to fill)
           //and the brush we want to use, specified by GDI 
           //The HBRUSH is a typecast, specifying it is a brush
           //the reason is that usually, you pass a pointer to a brush object
           //but sometimes, for build in windows colors, you pass an integer , which s why the offset
           // + 1 is required to make it an int, but of course since it is supposed to take a brush
           //this would upset the compiler without casting it to a brush
           //This is just. really bad design frankly
           FillRect(hdc, &ps.rcPaint, (HBRUSH) (COLOR_HIGHLIGHT+1)); 
           EndPaint(hwnd, &ps);
        };
    case WM_CREATE:
        {
            //-----initialize the bitmap we will be writing to-----
                
            //pointer to our pixel data, must be void because we don't yet know if it will be 32 bit, 64 bit etc. bitmap
            *void pixelDataPtr;

            //handle to the device context for the client area of the window we want to write to 
            HDC hdc = getDC(hwnd); 

            //@param 1 the handle to the client area of the window
            //@param 2 - BITMAPINFO
            //@param 3 - a description of how bmiColors is specified in the BITMAPINFO, so GDI knows how to interpret it
            // as you can either specify the colors directly as rgb values, or in another fancier way I am not doing right now
            //@param 4 - the pointer to our pixel data
            //@param 5 - handle to file mapping section - MTF
            //@param 6 - only matters is param 5 isn't NULL
            HBITMAP CreateDIBSection(hdc, __UNKNOWN__, DIB_RGB_COLORS. pixelDataPtr, NULL, NULL);

            //we need to create a struct to hold application data, like the pixel data that winProc can write to and use
            //and the bitmap handle which points to a struct containing both the pixel data, and other data like the colour table
            //windows GDI will use the provided data alongside the pixel data we wrote to draw the correct image
            //
            //summary; I will create the image by writing to the space in memory pointed to by our pixel data pointer, then i give GDI the handle to the bitmap generally, and it will use that pixel data, alongside the other data, like the color table, to draw to the screen
            //This is storing both of those pointers in a struct which I can then associate with the window
            LONG_PTR rendererDataStructPtr = {
            }


            //we want to create a bitmap and store a reference to it with our window
            //so that it is accesible by winProc to write to
            
            //pointer to the user data stored alongside window, this will include our bitmap
            //@param 1 - takes the handle to the window
            //@param 2 - an integer defining an index for which block of data associated with the window
            //we want to associate this with - GWLP_USER_DATA, is an area defined for the application to use
            //for storing this sort of user / application data. It resolved to -21 afaik. 
            //@param 3 - the pointer to the data we want to associate with our window
            LONG_PTR windowUserDataPtr = SetWindowLongPtr(hwnd, GWLP_USER_DATA, rendererDataStructPtr)
        }
    }
    //what
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

// hInstance - essentially a pointer to this module (executable)  
// hprevInstance is always NULL on modern OS (awesome) , kept for backwards compatibility
// lpCmdLine - command line arguments (as unicode string) 
// nCmdShow - flag describing if the application is minimixed or maximized, etc
// WINAPI just expands to be "__stdcall" which is a calling convention - it specifies how arguments are pushed onto the stack
// and that the function is responsible for cleaning up the stack itself before return
// also causes the function name to be decorated to _WinMain@<number of bytes of parameters> 
// name change is mostly helpful for cpp applications where two functions can have the same name 
// 
// One could literally just write int __stdcall WinMain ... instead
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){
    char CLASS_NAME[] = "windowClass";
    WNDCLASSEXA wc = { };
    wc.hInstance = hInstance;  //several programs might create a window class with the same name
    wc.cbSize = sizeof(WNDCLASSEXA);                  //need to provide the location so the OS knows which one we are referring to
    wc.lpfnWndProc = WndProc; //this is the function called when something happens (main message handling loop)
    wc.lpszClassName = CLASS_NAME; 

    //tells the operating system to take the WINDCLASS structure and store it in a lookup table, with 
    //a combination of the hInstance and classname as a key (hInstance to ensure uniqueness)
    RegisterClassEx(&wc); //passes address of wc to registerClass 
    
    //a pointer, HWND is just a *void. It will be set to point to the place in kernel memory
    HWND hwnd; //where the instance of the window we create lives
    hwnd = CreateWindowEx(
        0, //optional window styles
        CLASS_NAME,
        "My first window!", //name of the window
        WS_OVERLAPPEDWINDOW, //window styles, others include things like WS_POPUP, etc
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, //size and position, in the order. x,y, width, height
        //here we are just allowing the operating system to decide. It has rules on how it will do this, but we could set these manually
        NULL, //parent window
        NULL, //menu - will dive deeper on this later I imagine
        hInstance, //so the OS knows which application owns this instance, important for lots of stuff!!  
        NULL //additional app data - not sure what might go here
    );

    //if that fails, crash out :3
    if (hwnd == NULL)
    {
        return 0;
    };
   
    //show our window by passing the pointer to our instance, and the flag param set 
    //that describes how it is opened (minimized, maximized, blah, blah). Think it depends on user settings
    ShowWindow(hwnd, nCmdShow);
    
    /*
     * interestingly , something like this wouldn't keep a GUI application alive
     * The OS doesn't treat is like a console application, and so doesn't
     * care about the loop unless it is the message loop it is expecting / performs
     * the message loop functionality
    while(1){
        //live
    };
    */

    MSG msg = { };
    //when something happens, it adds the event to the message queue,
    //get message reads from that queue
    //takes a pointer to the object it will fill with the event information 
    //@param 2 - window for which messages you want to retrieve, NULL specifies all for the current thread
    //#param 3 - can specify a message index to start looking from, setting this to 0 fetches all messages
    //@param 4 - like 3, but the upper bound of messages to retrieve
    while (GetMessage(&msg, NULL, 0, 0) > 0)
    {
        TranslateMessage(&msg); //from key down and key up messgaes, translates to a single asci or unicode keycode character
        //it places this KEYCODE message back in the queue now that it is translated, when it comes across that keycode
        //message, it will just ignore it because it only operates on keypress messages
        DispatchMessage(&msg); //sends the message to the wproc function
    }

    return 0;
};


void drawLine(){
   //quuee message    
}
