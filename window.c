#include <stdio.h>
#include <windows.h> 

//callback called by the application when something happens
//CALLBACK macro evaluated to the same thing as WINAPI (__stdcall)
//But indicates that the operating system calls this, rather than the application
LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
 switch (uMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    //paint is generated by the OS to do things like create the window and resize ti etc
    //the application itself can also send these though
    case WM_PAINT:
        //in C, cases need brackets if a variable is declared in them, to keep them to the right scope
        {
           //still need to dive into what beginpaint does to this struct
           PAINTSTRUCT ps; 
           HDC hdc = BeginPaint(hwnd, &ps);
           //also need to dive into what this does
           FillRect(hdc, &ps.rcPaint, (HBRUSH) (COLOR_WINDOW+1)); 
           EndPaint(hwnd, &ps);
        }
    }
    //what
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

// hInstance - essentially a pointer to this module (executable)  
// hprevInstance is always NULL on modern OS (awesome) , kept for backwards compatibility
// lpCmdLine - command line arguments (as unicode string) 
// nCmdShow - flag describing if the application is minimixed or maximized, etc
// WINAPI just expands to be "__stdcall" which is a calling convention - it specifies how arguments are pushed onto the stack
// and that the function is responsible for cleaning up the stack itself before return
// also causes the function name to be decorated to _WinMain@<number of bytes of parameters> 
// name change is mostly helpful for cpp applications where two functions can have the same name 
// 
// One could literally just write int __stdcall WinMain ... instead
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){
    char CLASS_NAME[] = "windowClass";
    WNDCLASSEXA wc = { };
    wc.hInstance = hInstance;  //several programs might create a window class with the same name
    wc.cbSize = sizeof(WNDCLASSEXA);                  //need to provide the location so the OS knows which one we are referring to
    wc.lpfnWndProc = WndProc; //this is the function called when something happens (main message handling loop)
    wc.lpszClassName = CLASS_NAME; 

    //tells the operating system to take the WINDCLASS structure and store it in a lookup table, with 
    //a combination of the hInstance and classname as a key (hInstance to ensure uniqueness)
    RegisterClassEx(&wc); //passes address of wc to registerClass 
    
    //a pointer, HWND is just a *void. It will be set to point to the place in kernel memory
    HWND hwnd; //where the instance of the window we create lives
    hwnd = CreateWindowEx(
        0, //optional window styles
        CLASS_NAME,
        "My first window!", //name of the window
        WS_OVERLAPPEDWINDOW, //window styles, others include things like WS_POPUP, etc
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, //size and position, in the order. x,y, width, height
        //here we are just allowing the operating system to decide. It has rules on how it will do this, but we could set these manually
        NULL, //parent window
        NULL, //menu - will dive deeper on this later I imagine
        hInstance, //so the OS knows which application owns this instance, important for lots of stuff!!  
        NULL //additional app data - not sure what might go here
    );

    //if that fails, crash out :3
    if (hwnd == NULL)
    {
        return 0;
    };
   
    //show our window by passing the pointer to our instance, and the flag param set 
    //that describes how it is opened (minimized, maximized, blah, blah). Think it depends on user settings
    ShowWindow(hwnd, nCmdShow);
    
    /*
     * interestingly , something like this wouldn't keep a GUI application alive
     * The OS doesn't treat is like a console application, and so doesn't
     * care about the loop unless it is the message loop it is expecting / performs
     * the message loop functionality
    while(1){
        //live
    };
    */

    MSG msg = { };
    //when something happens, it adds the event to the message queue,
    //get message reads from that queue
    //takes a pointer to the object it will fill with the event information 
    //@param 2 - window for which messages you want to retrieve, NULL specifies all for the current thread
    //#param 3 - can specify a message index to start looking from, setting this to 0 fetches all messages
    //@param 4 - like 3, but the upper bound of messages to retrieve
    while (GetMessage(&msg, NULL, 0, 0) > 0)
    {
        TranslateMessage(&msg); //from key down and key up messgaes, translates to a single asci or unicode keycode character
        //it places this KEYCODE message back in the queue now that it is translated, when it comes across that keycode
        //message, it will just ignore it because it only operates on keypress messages
        DispatchMessage(&msg); //sends the message to the wproc function
    }

    return 0;
};

